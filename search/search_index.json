{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"E-Commerce UI kit Hello \ud83d\udc4b This documentation will help you to more easily understand how to use the E-Commerce UI kit. The UI Kit is made to be easily customizable and extendable. Also, It's structure will let you to maintain it and connect it to back-end so much fast. After seting up the enviroment , You can head into other sections and explore docs or run the application and enjoy it.","title":"Home"},{"location":"#e-commerce-ui-kit","text":"Hello \ud83d\udc4b This documentation will help you to more easily understand how to use the E-Commerce UI kit. The UI Kit is made to be easily customizable and extendable. Also, It's structure will let you to maintain it and connect it to back-end so much fast. After seting up the enviroment , You can head into other sections and explore docs or run the application and enjoy it.","title":"E-Commerce UI kit"},{"location":"about/","text":"","title":"About"},{"location":"add-new-feature/","text":"Creating a new page To create a new page, first of all consider if the new page should be in already defiend modules or not. If it wasn't then goto Creating a new module 1. Create page classes Choose the module and then head into the presentation folder of it. Create a new folder for new page and also create the files page.dart and controller.dart . In page.dart add the widget and in controller.dart add the statemangment codes with any package you like to use. All you have to do is to retreive data from application layer and pump it to the widgets. After creating the page, You have also create a route for it. The routes of pages of a module are in presentation/routes.dart file. After you created a route, You need to register the page in MaterialApp . 2. Registering page in MaterialApp main.dart file of every module contains a variable called routes which is used to register the routes. You need to add the string variable of route (which you created in previous step) in this Map and then map it to the page you just created. All routes from all modules are gathered in the MaterialApp. It's Also the same for onGeneratedRoutes . After doing these steps you are able to navigate to new page. Create a new module If you are adding new features to the app and they don't blong to already created modules, Then follow these steps to create a new module. As we spoke earlier, Every module has the same structure. You can see Module structure and get familiar with it. So basically all you need to do is create these folders and then add the classes that you need. Also feel free to look at already created modules or copy them and change the names.","title":"Adding a new feature"},{"location":"add-new-feature/#creating-a-new-page","text":"To create a new page, first of all consider if the new page should be in already defiend modules or not. If it wasn't then goto Creating a new module","title":"Creating a new page"},{"location":"add-new-feature/#1-create-page-classes","text":"Choose the module and then head into the presentation folder of it. Create a new folder for new page and also create the files page.dart and controller.dart . In page.dart add the widget and in controller.dart add the statemangment codes with any package you like to use. All you have to do is to retreive data from application layer and pump it to the widgets. After creating the page, You have also create a route for it. The routes of pages of a module are in presentation/routes.dart file. After you created a route, You need to register the page in MaterialApp .","title":"1. Create page classes"},{"location":"add-new-feature/#2-registering-page-in-materialapp","text":"main.dart file of every module contains a variable called routes which is used to register the routes. You need to add the string variable of route (which you created in previous step) in this Map and then map it to the page you just created. All routes from all modules are gathered in the MaterialApp. It's Also the same for onGeneratedRoutes . After doing these steps you are able to navigate to new page.","title":"2. Registering page in MaterialApp"},{"location":"add-new-feature/#create-a-new-module","text":"If you are adding new features to the app and they don't blong to already created modules, Then follow these steps to create a new module. As we spoke earlier, Every module has the same structure. You can see Module structure and get familiar with it. So basically all you need to do is create these folders and then add the classes that you need. Also feel free to look at already created modules or copy them and change the names.","title":"Create a new module"},{"location":"add-new-language/","text":"Follow these steps to add a new language Create translations file in locale/ folder. The translation file should be a JSON file and named as the language you are trying to add. example locale/en-US.json locale/en-UK.json `locale/de-DE.json' Open lib/main.dart file and add the new locale to supportedLocales of EasyLocalization (line 54). After this, The locale will be shown if the user device has the same locale. Setting as the default locale You can add a startLocale in EasyLocalization widget in lib/main.dart and this locale will be the default locale for your app. Setting as the fallback locale Fallback locale is when the device locale is not supported by the app. You can add a fallbackLocale in EasyLocalization widget in lib/main.dart and this locale will be used when the device locale is not supported by the app.","title":"Adding a new language"},{"location":"add-new-language/#setting-as-the-default-locale","text":"You can add a startLocale in EasyLocalization widget in lib/main.dart and this locale will be the default locale for your app.","title":"Setting as the default locale"},{"location":"add-new-language/#setting-as-the-fallback-locale","text":"Fallback locale is when the device locale is not supported by the app. You can add a fallbackLocale in EasyLocalization widget in lib/main.dart and this locale will be used when the device locale is not supported by the app.","title":"Setting as the fallback locale"},{"location":"customization/","text":"Changing package name We suggest using rename to change the name and package name of the application. First step is to run pub global activate rename And then you can easily change application name and package name. pub global run rename --bundleId com.init.commerce.app pub global run rename --appname \"Init Commerce\" Changing logo To change the logo, Change assets/images/logo.png and assets/images/logo_image.png . Changing application icon The application icon is located in assets/icons/icon.png , After changing the icon, You need to run command flutter pub run flutter_launcher_icons:main To apply changes. Changing appearance You can change the theme of the application by changing the theme variable in lib/config/appearance.dart file. final Map<String, dynamic> appearance = { 'defaultTheme': 'light', 'theme': {'light': purpleTheme} }; The default theme is created before and you can change theme using this map. Error codes Since errors are mostly related to the back-end, We have Map called errors in config/main.dart This varibale maps the error codes to their error messages, Which may show up in snackbars.","title":"Customization"},{"location":"customization/#changing-package-name","text":"We suggest using rename to change the name and package name of the application. First step is to run pub global activate rename And then you can easily change application name and package name. pub global run rename --bundleId com.init.commerce.app pub global run rename --appname \"Init Commerce\"","title":"Changing package name"},{"location":"customization/#changing-logo","text":"To change the logo, Change assets/images/logo.png and assets/images/logo_image.png .","title":"Changing logo"},{"location":"customization/#changing-application-icon","text":"The application icon is located in assets/icons/icon.png , After changing the icon, You need to run command flutter pub run flutter_launcher_icons:main To apply changes.","title":"Changing application icon"},{"location":"customization/#changing-appearance","text":"You can change the theme of the application by changing the theme variable in lib/config/appearance.dart file. final Map<String, dynamic> appearance = { 'defaultTheme': 'light', 'theme': {'light': purpleTheme} }; The default theme is created before and you can change theme using this map.","title":"Changing appearance"},{"location":"customization/#error-codes","text":"Since errors are mostly related to the back-end, We have Map called errors in config/main.dart This varibale maps the error codes to their error messages, Which may show up in snackbars.","title":"Error codes"},{"location":"module-structure/","text":"Modules The modules are an implementation of Domain-Driven-Design in flutter. This architecture will help you to maintain project more easily and add features without manipulating old codes. The modules are designed in a way that you can completely remove or add them. Main View Every Module should use this format my_module \u251c\u2500\u2500 application \u2502 \u251c\u2500\u2500 domain \u2502 \u2502\u2500\u2500 entity \u2502 \u2514\u2500\u2500 interface \u2502 \u251c\u2500\u2500 infrastructure \u2502 \u251c\u2500\u2500 model \u2502 \u251c\u2500\u2500 provider \u2502 \u2514\u2500\u2500 repository \u2502 \u251c\u2500\u2500 presentation \u2502 \u251c\u2500\u2500 page \u2502 \u251c\u2500\u2500 widgets \u2502 \u2514\u2500\u2500 routes.dart \u2502 \u251c\u2500\u2500 injections.dart \u251c\u2500\u2500 api.dart \u2514\u2500\u2500 main.dart Sections Application This folder has the classes implemented with facade pattern. These classes always have a Service suffix. for example SearchService and AuthService . A service uses repositories and act as an interface between infrastructre and presentation. Domain The domain folder contains the shared models used in the presentation and infrastructure. Entity Entity folder is used specially for classes with unique id. The entity classes will be used directly in the presentation layer and they will be extended in infrastructure so providers can use them. Interface Interfaces will help you to correctly implement application and infrastructre layers Infrastructure The root of data is here. This layer is the lowest layer in the module and contains providers to connect with different data sources such as server api, google api, local storage functionallities and etc. Model Model folder will be a place to put extended models from domanin and add extra method (like json serialization) so providers can use them Provider Our provider will support us with data from servers and other data sources. This folder may contains multiple classes to access data. Repository Providers will be used in this layer and we gather them togheter. this class can only be access by application layer. Presentation The UI of app will be located here, also this folder should contain a routes.dart which determine name of our routes. injections.dart This file contains a method to register dependecies in memory using the get_it service locator. classes like providers, repositories, services and presenetion state notifier can be registered in memory from this method. eg: Future<void> registerDependencies() async { // Repository serviceLocator.registerLazySingleton<ProductRepository>( () => ProductRepository( localProductProvider: serviceLocator(), remoteProductProvider: serviceLocator(), ), ); //Providers serviceLocator.registerLazySingleton<LocalProductProvider>( () => const LocalProductProvider(), ); serviceLocator.registerLazySingleton<RemoteProductProvider>( () => const RemoteProductProvider(), ); } api.dart Api class will help you connect modules togheter and use this module functionallities in other modules. class SearchApi { List<Product> searchForKeyword(String keyword) { // code } } main.dart As you can from it's name, it's the main class of this module which represents this module in one single class and other classes can only have access to this file. This class contains a api from previous api.dart , a list of routes so they can be registered in material app and also a initial route that determine what is the start point of this module.","title":"Module structure"},{"location":"module-structure/#modules","text":"The modules are an implementation of Domain-Driven-Design in flutter. This architecture will help you to maintain project more easily and add features without manipulating old codes. The modules are designed in a way that you can completely remove or add them.","title":"Modules"},{"location":"module-structure/#main-view","text":"Every Module should use this format my_module \u251c\u2500\u2500 application \u2502 \u251c\u2500\u2500 domain \u2502 \u2502\u2500\u2500 entity \u2502 \u2514\u2500\u2500 interface \u2502 \u251c\u2500\u2500 infrastructure \u2502 \u251c\u2500\u2500 model \u2502 \u251c\u2500\u2500 provider \u2502 \u2514\u2500\u2500 repository \u2502 \u251c\u2500\u2500 presentation \u2502 \u251c\u2500\u2500 page \u2502 \u251c\u2500\u2500 widgets \u2502 \u2514\u2500\u2500 routes.dart \u2502 \u251c\u2500\u2500 injections.dart \u251c\u2500\u2500 api.dart \u2514\u2500\u2500 main.dart","title":"Main View"},{"location":"module-structure/#sections","text":"","title":"Sections"},{"location":"module-structure/#application","text":"This folder has the classes implemented with facade pattern. These classes always have a Service suffix. for example SearchService and AuthService . A service uses repositories and act as an interface between infrastructre and presentation.","title":"Application"},{"location":"module-structure/#domain","text":"The domain folder contains the shared models used in the presentation and infrastructure.","title":"Domain"},{"location":"module-structure/#entity","text":"Entity folder is used specially for classes with unique id. The entity classes will be used directly in the presentation layer and they will be extended in infrastructure so providers can use them.","title":"Entity"},{"location":"module-structure/#interface","text":"Interfaces will help you to correctly implement application and infrastructre layers","title":"Interface"},{"location":"module-structure/#infrastructure","text":"The root of data is here. This layer is the lowest layer in the module and contains providers to connect with different data sources such as server api, google api, local storage functionallities and etc.","title":"Infrastructure"},{"location":"module-structure/#model","text":"Model folder will be a place to put extended models from domanin and add extra method (like json serialization) so providers can use them","title":"Model"},{"location":"module-structure/#provider","text":"Our provider will support us with data from servers and other data sources. This folder may contains multiple classes to access data.","title":"Provider"},{"location":"module-structure/#repository","text":"Providers will be used in this layer and we gather them togheter. this class can only be access by application layer.","title":"Repository"},{"location":"module-structure/#presentation","text":"The UI of app will be located here, also this folder should contain a routes.dart which determine name of our routes.","title":"Presentation"},{"location":"module-structure/#injectionsdart","text":"This file contains a method to register dependecies in memory using the get_it service locator. classes like providers, repositories, services and presenetion state notifier can be registered in memory from this method. eg: Future<void> registerDependencies() async { // Repository serviceLocator.registerLazySingleton<ProductRepository>( () => ProductRepository( localProductProvider: serviceLocator(), remoteProductProvider: serviceLocator(), ), ); //Providers serviceLocator.registerLazySingleton<LocalProductProvider>( () => const LocalProductProvider(), ); serviceLocator.registerLazySingleton<RemoteProductProvider>( () => const RemoteProductProvider(), ); }","title":"injections.dart"},{"location":"module-structure/#apidart","text":"Api class will help you connect modules togheter and use this module functionallities in other modules. class SearchApi { List<Product> searchForKeyword(String keyword) { // code } }","title":"api.dart"},{"location":"module-structure/#maindart","text":"As you can from it's name, it's the main class of this module which represents this module in one single class and other classes can only have access to this file. This class contains a api from previous api.dart , a list of routes so they can be registered in material app and also a initial route that determine what is the start point of this module.","title":"main.dart"},{"location":"project-structure/","text":"Project structure The architecture of this project is an inspiration from domain driven design so you can easily maintain and develop it. lib/ main.dart helpers/ config/ common/ modules/ auth/ home/ search/ cart/ profile/ helpers The helpers folder consist of a set of tools including error handler, snackbar service and etc. config Config folder just like it's name has the project configuration including it's theme, back-end address and other configs. common Basically common folder is used to create common classes between modules. You can find common widgets, mixins and other stuff in this folder. modules This folder contains the sub-domains or modules of this application. We created different modules to seperate application different sections. For example the auth module is only responsible for authenticating users. A basic structure of a module is moduleName/ main.dart # main file of module injections.dart # dependency injections api.dart # an api to work with other modules domain/ entity/ # shared models interface/ # interfaces for other classes infrastructre/ # where the data comes in provider/ # data sources for application model/ # extended entities to work with providers repository/ # where we use data sources and gather them in one class application/ # the classes with facade pattern which uses repositories in infrastructre presentation/ # pages of the modules pageName/ page.dart controller.dart This structure helps you to develop and maintain codes much more easily. The modules are created in a way that you can completely remove them from the project or add a new one. Also some modules are depended to each other, for example the home module needs","title":"Project structure"},{"location":"project-structure/#project-structure","text":"The architecture of this project is an inspiration from domain driven design so you can easily maintain and develop it. lib/ main.dart helpers/ config/ common/ modules/ auth/ home/ search/ cart/ profile/","title":"Project structure"},{"location":"project-structure/#helpers","text":"The helpers folder consist of a set of tools including error handler, snackbar service and etc.","title":"helpers"},{"location":"project-structure/#config","text":"Config folder just like it's name has the project configuration including it's theme, back-end address and other configs.","title":"config"},{"location":"project-structure/#common","text":"Basically common folder is used to create common classes between modules. You can find common widgets, mixins and other stuff in this folder.","title":"common"},{"location":"project-structure/#modules","text":"This folder contains the sub-domains or modules of this application. We created different modules to seperate application different sections. For example the auth module is only responsible for authenticating users. A basic structure of a module is moduleName/ main.dart # main file of module injections.dart # dependency injections api.dart # an api to work with other modules domain/ entity/ # shared models interface/ # interfaces for other classes infrastructre/ # where the data comes in provider/ # data sources for application model/ # extended entities to work with providers repository/ # where we use data sources and gather them in one class application/ # the classes with facade pattern which uses repositories in infrastructre presentation/ # pages of the modules pageName/ page.dart controller.dart This structure helps you to develop and maintain codes much more easily. The modules are created in a way that you can completely remove them from the project or add a new one. Also some modules are depended to each other, for example the home module needs","title":"modules"},{"location":"running-the-app/","text":"You can the app using your IDE or straight from the command line. Run in debug mode flutter run Run in release mode flutter run --release Build application (Android) flutter build apk","title":"Running the App"},{"location":"setup-enviroment/","text":"Setup SDK This UI kit is written in Flutter so you will need Flutter SDK to run this application. Below are steps to install Flutter SDK based on your OS. MacOS Linux Windows ChromeOS After installing Flutter, You need to install Android SDK or iOS SDK. Setup an Editor You will need an IDE to use Flutter more efficiently. Of course you can use Android studio from previous section. We suggest VSCode But you can use any other IDE which supports Flutter. Flutter website has a list of supported IDEs and instructions are available here . After installing VSCode, Install flutter plugins. Then you will be able to run the UI Kit immediately (Run application)[]","title":"Setup enviroment"},{"location":"setup-enviroment/#setup-sdk","text":"This UI kit is written in Flutter so you will need Flutter SDK to run this application. Below are steps to install Flutter SDK based on your OS. MacOS Linux Windows ChromeOS After installing Flutter, You need to install Android SDK or iOS SDK.","title":"Setup SDK"},{"location":"setup-enviroment/#setup-an-editor","text":"You will need an IDE to use Flutter more efficiently. Of course you can use Android studio from previous section. We suggest VSCode But you can use any other IDE which supports Flutter. Flutter website has a list of supported IDEs and instructions are available here . After installing VSCode, Install flutter plugins. Then you will be able to run the UI Kit immediately (Run application)[]","title":"Setup an Editor"}]}